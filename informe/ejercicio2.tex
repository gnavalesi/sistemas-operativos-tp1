\section{Ejercicio 2}


\subsection{\mintinline{c++}{void push_front(const T& val)}}

\begin{minted}[tabsize=4]{c++}
void push_front(const T& val) {
	Nodo *newHead = new Nodo(val);
	newHead->_next = _head.exchange(newHead);
}
\end{minted}

Como \mintinline{c++}{_head.exchange(newHead)} cambia el valor de \mintinline{c++}{_head} por el de \mintinline{c++}{newHead} y devuelve su valor anterior de forma atómica, no hay condiciones de carrera sobre esta variable y \mintinline{c++}{newHead} pasa a ser el primer elemento de la lista. Dado que la asignación de \mintinline{c++}{newHead->_next} no es atómica, no se puede garantizar que inmediatamente después del \mintinline{c++}{exchange} \mintinline{c++}{newHead} esté enlazada al valor que tenía \mintinline{c++}{_head} antes del \mintinline{c++}{exchange}; es posible que en este período se agregue otro nodo delante de \mintinline{c++}{newHead}. Pero dado que \mintinline{c++}{_head.exchange(newHead)} devuelve el valor anterior de \mintinline{c++}{_head} atómicamente, la asignación lo guardará en \mintinline{c++}{newHead->_next} eventualmente y los nodos quedarán correctamente enlazados.


\subsection{\mintinline{c++}{ConcurrentHashMap count_words(string arch)}}

\begin{minted}{c++}
ConcurrentHashMap count_words(string arch) {
	ConcurrentHashMap map;
	Leer el archivo arch guardando cada palabra en una lista de strings
	Por cada palabra de la lista hacer map.addAndInc(palabra)
	return map
}
\end{minted}


\subsection{\mintinline{c++}{ConcurrentHashMap count_words(list<string> archs)}}

\begin{minted}{c++}
ConcurrentHashMap count_words(list<string> archs) {
	ConcurrentHashMap map;
	list<string>::iterator iterador = archs.begin();
	mutex iterador_mutex;
	Crear un thread por cada elemento de archs {
		Activar lock de iterador
		Guardar iterador en it
		Si iterador != archs.end(), avanzar iterador
		Desactivar lock de iterador
		Si it != archs.end(), contar en map las palabras del archivo apuntado por it con addAndInc
	}
	Esperar a que terminen los threads
	return map
}
\end{minted}

Hacer locking de iterador asegura que cada thread obtenga un archivo único de la lista de archivos.


\subsection{\mintinline{c++}{ConcurrentHashMap count_words(unsigned int n, list<string> archs)}}

\begin{minted}{c++}
ConcurrentHashMap count_words(list<string> archs) {
	ConcurrentHashMap map;
	list<string>::iterator iterador = archs.begin();
	mutex iterador_mutex;
	Crear n threads {
		bool quedan_archivos = true;
		Mientras quedan_archivos {
			Activar lock de iterador
			quedan_archivos = iterador != archs.end();
			Si quedan_archivos {
				Guardar en arch el archivo apuntado por iterador
				Avanzar iterador
			}
			Desactivar lock de iterador
			Si quedan_archivos, contar en map las palabras del archivo apuntado por it con addAndInc
		}
	}
	Esperar a que terminen los threads
	return map
}
\end{minted}

Hacer locking de iterador asegura que cada thread obtenga un archivo único de la lista de archivos. El ciclo hace que los threads sigan procesando archivos siempre que queden archivos sin procesar.


\subsection{\mintinline{c++}{item maximum(unsigned int p_archivos, unsigned int p_maximos, list<string> archs)}}

\begin{minted}{c++}
item maximum(unsigned int p_archivos, unsigned int p_maximos, list<string> archs) {
	list<ConcurrentHashMap*> maps;
	Insertar un ConcurrentHashMap* en maps por archivo en archs
	list<ConcurrentHashMap>::iterator maps_iterador = maps.begin();
	list<string>::iterator archs_iterador = archs.begin();
	mutex iteradores_mutex;
	Crear p_archivos threads {
		bool quedan_archivos = true;
		Mientras quedan_archivos {
			Activar lock de los iteradores
			quedan_archivos = arch_iterador != archs.end();
			Si quedan_archivos {
				Guardar en arch el archivo apuntado por arch_iterador
				Avanzar arch_iterador
				Guardar en map el ConcurrentHashMap* apuntado por maps_iterador
				Avanzar map_iterador
			}
			Desactivar lock de los iteradores
			Si quedan_archivos, contar en *map las palabras del archivo apuntado por it con addAndInc
		}
	}
	Esperar a que terminen los threads
	Juntar los mapas de maps en un mapa general_map
	return general_map.maximum(p_maximos);
}
\end{minted}

Hacer locking de los iteradores asegura que cada thread obtenga un archivo y un mapa único.